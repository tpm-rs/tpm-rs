//! Deterministic Random Bit Generator. Heavily inspired by
//! <https://docs.rs/rand_core>

mod error;
pub mod helpers;
pub use error::DrbgError;

/// This trait wraps functionalities common to all Deterministic Random Bit
/// Generators.
///
/// Three different methods for generating random data are required similar to
/// [RngCore](https://docs.rs/rand_core/latest/rand_core/trait.RngCore.html).
/// There is no required relationship between the output of each; e.g. an
/// implementations of [`fill_bytes`] may consume a whole number of u32 or
/// u64 values and drop any remaining unused bytes. The same can happen
/// with the [`next_u32`] and [`next_u64`] methods, implementations may
/// discard some random bits for efficiency.
/// Implementation should normally have portable, reproducible output,
/// i.e. fix Endianness when converting values to avoid platform
/// differences, and avoid making any changes which affect output.
///
/// A DRBG may implement only one of the [`next_u32`], [`next_u64`],
/// [`fill_bytes`] methods available in this trait directly, then use
/// the helper functions from the [helpers] module to implement the
/// other methods.
///
/// ## Implementing [`Drbg`] for large entropy or nonce
///
/// Note that the required traits [`Default`] and
/// [`AsMut<u8>`] are not implemented for large arrays
/// [u8; N] with N > 32. To be able to implement the traits required
/// by SeedableRng for RNGs with such large seeds, the newtype pattern
/// can be used:
///
/// ```rust
/// const N: usize = 64;
/// pub struct MyRngSeed(pub [u8; N]);
///
/// impl Default for MyRngSeed {
///     fn default() -> MyRngSeed {
///         MyRngSeed([0; N])
///     }
/// }
///
/// impl AsMut<[u8]> for MyRngSeed {
///     fn as_mut(&mut self) -> &mut [u8] {
///         &mut self.0
///     }
/// }
/// ```
///
/// [`fill_bytes`]: Drbg::fill_bytes
/// [`next_u32`]: Drbg::next_u32
/// [`next_u64`]: Drbg::next_u64
/// [`Default`]: core::default::Default
/// [`AsMut<u8>`]: core::convert::AsMut<u8>
pub trait Drbg: Sized {
    /// Type for the Drbg Seed, which should be high quality entropy data ideally generated by
    /// [`EntropySource`].It is restricted to types mutably-dereferenceable as u8 arrays
    /// (we recommend either `[u8; N]` for some `N` or `GenericArray<u8, N>`).
    ///
    /// [`EntropySource`]: crate::platform::crypto::EntropySource
    type Entropy: Sized + Default + AsMut<[u8]>;
    /// Nonce type, which is restricted to types mutably-dereferenceable as u8 arrays
    /// (we recommend either `[u8; N]` for some `N` or `GenericArray<u8, N>`).
    ///
    /// According to 8.6.7: A nonce may be composed of one (or more) of the following
    /// components (other components may also be appropriate):
    ///
    /// 1. A random value that is generated anew for each nonce, using an approved random bit
    ///    generator.
    /// 2. A timestamp of sufficient resolution (detail) so that it is different each time it
    ///    is used.
    /// 3. A monotonically increasing sequence number.
    /// 4. A combination of a timestamp and a monotonically increasing sequence number, such
    ///    that the sequence number is reset when and only when the timestamp changes. For
    ///    example, a timestamp may show the date but not the time of day, so a sequence
    ///    number is appended that will not repeat during a particular day.
    ///
    /// For case 1 above, the random value could be acquired from the same source and at the same time
    /// as the entropy input. For case 2 above, the timestamp must be trusted. A trusted timestamp is
    /// generated and signed by an entity that is trusted to provide accurate time information.
    type Nonce: Sized + Default + AsMut<[u8]>;
    /// Create a new DRBG using the given seed.
    ///
    /// All PRNG implementations should be reproducible: given a fixed seed,
    /// the same sequence of output should be produced on all runs, library
    /// versions and architectures (e.g. check endianness).
    /// # Error
    /// This function may fail in one of two cases:
    /// 1. `additional_input` is too large.
    /// 2. Internal Errors in case of hardware drbg.
    fn instantiate(
        entropy_input: &Self::Entropy,
        nonce: &Self::Nonce,
        personalization_string: &[u8],
    ) -> Result<Self, DrbgError>;
    /// Add additional entropy to th current RNG
    ///
    /// All PRNG implementations should be reproducible: given a fixed seed,
    /// the same sequence of output should be produced on all runs, library
    /// versions and architectures (e.g. check endianness).
    /// # Error
    /// This function may fail in one of two cases:
    /// 1. `additional_input` is too large.
    /// 2. Internal Errors in case of hardware drbg.
    fn reseed(
        &mut self,
        entropy_input: &Self::Entropy,
        additional_input: &[u8],
    ) -> Result<(), DrbgError>;
    /// Return the next random [u32].
    ///
    /// In the case this method is not implemented directly, it can be
    /// implemented using `self.next_u64() as u32` or via
    /// [helpers::next_u32_via_fill].
    /// # Error
    /// This function may fail in one of three cases:
    /// 1. `additional_input` is too large.
    /// 2. DRBG requires reseeding.
    /// 3. Internal Errors in case of hardware drbg.
    fn next_u32(&mut self, additional_input: &[u8]) -> Result<u32, DrbgError>;
    /// Return the next random [u64].
    ///
    /// In the case this method is not implemented directly, it can be
    /// implemented via [helpers::next_u64_via_u32] or via
    /// [helpers::next_u64_via_fill].
    /// # Error
    /// This function may fail in one of three cases:
    /// 1. `additional_input` is too large.
    /// 2. DRBG requires reseeding.
    /// 3. Internal Errors in case of hardware drbg.
    fn next_u64(&mut self, additional_input: &[u8]) -> Result<u64, DrbgError>;
    /// Fill `dest` with random data.
    ///
    /// In the case this method is not implemented directly, it can be
    /// implemented via [helpers::fill_bytes_via_next].
    ///
    /// This method should guarantee that `dest` is entirely filled with
    /// new data.
    ///
    /// # Error
    /// This function may fail in one of four cases:
    /// 1. Requested `dest` is too large.
    /// 2. `additional_input` is too large.
    /// 2. DRBG requires reseeding.
    /// 3. Internal Errors in case of hardware drbg.
    fn fill_bytes(&mut self, additional_input: &[u8], dest: &mut [u8]) -> Result<(), DrbgError>;
    /// returns true if drbg must be reseeded, false otherwise
    fn requires_reseeding(&mut self) -> bool;
}
